var documenterSearchIndex = {"docs":
[{"location":"improvements.html#Improvements","page":"Improvements","title":"Improvements","text":"","category":"section"},{"location":"improvements.html#Obs.v_imp","page":"Improvements","title":"Obs.v_imp","text":" v_imp(vv,vt...;cv, L=1, theta1,theta2, bnd::Boundary=open)\n v_imp(vv::juobs.Corr,vt::juobs.Corr...;cv,L=1, theta1=Float64[],theta2=Float64[], bnd::Boundary=open)\n\nCompute the improved G{VV} =  \\sum{k=1}^3G{ViV_i} correlator according to the equations\n\n    G^I_V_iV_i = G_V_i V_i + 2ac_V de_t G_V_i T_i0 - 2c_V sum_j=1^3 i sin(p^j a) G_V_i T_ij\n\nArguments\n\nvv: correlator G_{VV}. It has to be already averaged over the three polarizations.\nvt: correlators G{VT}. It should be either G{ViT0i} (already averaged     over the three polarizations) if the correlator is at 0 momentum or     G{ViT0i}, G{V1T12},G{V1T13}, G{V2T12},G{V2T23}, G{V3T13},G_{V3T23} if at     non-zero momentum\n\nKeyword Arguments\n\ncv: mandatory keyword argument. It is the improvement coefficient\nL::Int64=1: Lattice size. Needed to convert the theta angle into momenta.\ntheta1=Float64[]: theta angle of the first quark. If empty, is read from vv\ntheta2=Float64[]: theta angles of the second quark. If empty, is read from vv\nbnd : Boundary condition of the lattice. Used to compute the derivatives\n\nSee also sym_der, Boundary\n\n\n\n\n\n","category":"function"},{"location":"improvements.html#Obs.pv_imp","page":"Improvements","title":"Obs.pv_imp","text":" pv_imp(pv,pt...;cv,L::Int64=1,theta1, theta2, bnd::Boundary = open)\n pv_imp(pv::juobs.Corr, pt::juobs.Corr...; cv, L=1, theta1=Float64[],theta2 = Float64[], bnd::Boundary=open)\n\nCompute the improved G{PV} =  1/3 \\sum{k=1}^3G{PVi} correlator according to the equations\n\n  G^I_PV_i = G_P V_i + ac_V de_t G_P T_i0 - c_V sum_j=1^3 sin(p^j a) G_P T_ij\n\nArguments\n\npv: correlator G_{PV}. It has to be already averaged over the three polarizations.\npt: correlators G{PT}. It should be either G{PT0i} (already averaged     over the three polarizations) if the correlator is at 0 momentum or     G{PT0i}, G{PT12},G{PT13},G{PT23} if at non-zero momentum\n\nKeyword Arguments\n\ncv: mandatory keyword argument. It is the improvement coefficient\nL::Int64=1: Lattice size. Needed to convert the theta angle into momenta.\ntheta1=Float64[]: theta angle of the first quark. If empty, is read from pv\ntheta2=Float64[]: theta angles of the second quark. If empty, is read from pv\nbnd : Boundary condition of the lattice. Used to compute the derivatives\n\nSee also sym_der, Boundary\n\n\n\n\n\n","category":"function"},{"location":"improvements.html#Obs.pv0_imp","page":"Improvements","title":"Obs.pv0_imp","text":" pv0_imp(pv0, pt...; theta1,theta2, cv,L::Int64=1, bnd::Boundary=open)\n pv0_imp(pv0::juobs.Corr,pt::juobs.Corr ...;cv,L=1,theta1 = Float64[], theta2 = Float64[], bnd::Boundary=open)::juobs.Corr\n\nImprove the correlator GPV0 and GPV0 with the tensor correlator according to the improvement equation\n\n    V_0^I(tvec p) = V_0(tvec p) - c_V sum_k=1^3 i sin(ap^k) T_0k(tvec p)\n\nArguments\n\npvo: correlator G_{PV0}\npt: correlators G{PT}. It contains the correlator G{PT01}, G{PT02}, G{PT03}\n\nKeyword Arguments\n\ncv: mandatory keyword argument. It is the improvement coefficient\nL::Int64=1: Lattice size. Needed to convert the theta angle into momenta.\ntheta1=Float64[]: theta angle of the first quark. If empty, is read from pv\ntheta2=Float64[]: theta angles of the second quark. If empty, is read from pv\nbnd : Boundary condition of the lattice. Used to compute the derivatives\n\nSee also sym_der, Boundary\n\n\n\n\n\n","category":"function"},{"location":"improvements.html#Obs.pa0_imp","page":"Improvements","title":"Obs.pa0_imp","text":"pa0_imp(pa0,pp; ca, bnd::Boundary =open)\npa0_imp(pa0::juobs.Corr,pp::juobs.Corr; ca, bnd::Boundary =open)::juobs.Corr\n\nImprove the correlator G{PA0} according to the equation\n\n    G_PA_0^I = G_PA_0 - a c_A de_t G_PP\n\nKeyword Arguments\n\nca: mandatory keyword argument. It is the improved operator [See also ca_fit]\nbnd : Boundary condition of the lattice. Used to compute the derivatives\n\nSee also sym_der, Boundary\n\n\n\n\n\n","category":"function"},{"location":"improvements.html#Obs.a0a0_imp","page":"Improvements","title":"Obs.a0a0_imp","text":"a0a0_imp(a0a0,pa0; ca,  bnd::Boundary=open)\na0a0_imp(a0a0::juobs.Corr,pa0::juobs.Corr; ca,  bnd::Boundary=open)::juobs.Corr\n\nImprove the correlator G{A0 A_0} according to the equation\n\n    G_A_0^I A_0^I = G_A_0 A_0 - 2 a c_A de_t G_P A_0\n\nKeyword Arguments\n\nca: mandatory keyword argument. It is the improved operator [See also ca_fit]\nbnd : Boundary condition of the lattice. Used to compute the derivatives\n\nSee also sym_der, Boundary\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities.html#Obs.sym_der","page":"Utilities","title":"Obs.sym_der","text":" sym_der(v,bnd::Boundary)\n\nCompute the symmetryc derivative of v according to the boundary condition in bnd See also Boundary\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#Obs.check_corr","page":"Utilities","title":"Obs.check_corr","text":" check_corr(c::juobs.Corr...; flag::Check_flag)\n\ncheck that all correlator are compatible. Use flag to ignore specific fields\n\nSee also Check_flag\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#Obs.average_corr","page":"Utilities","title":"Obs.average_corr","text":" average_corr(x::juobs.Corr...; flag::Check_flag = no_gamma)\n\nIt average the correlator x.... It first check for compatibility among the correlator according to flag. It is meant to average correlator with vector and tensor currents and flag = no_gamma.\n\nOutput Specifics\n\nThe function returns a juobs.Corr with gamma structure made by appending the gamma structure of the original correlator, so that if we average three correlator with gamma structure G1, G2 and G3, the returned correlator has gamma structure G1,G2,G3.\n\n#TODO: if flags is something different that no_gamma, the correlators will be averaged correctly but other informations will be lost (:kappa, :mu, ecc...)\n\nSee also check_corr, Check_flag\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#Obs.sym_source","page":"Utilities","title":"Obs.sym_source","text":"sym_source(corr, y0, parity, bnd::Boundary = open)\nsym_source(corr::juobs.Corr [,y0], parity, bnd::Boundary = open)\n\nsymmetrize the correlator with respect to the source position y0\n\nArguments\n\ny0 source position in Julia indexing.\nparity parity of the correlator. should be \\pm 1\nbnd the boundary condition of the correlator\n\nReturn types\n\n(1) returns a vector of the same type as corr\n(2) returns a juobs.Corr\n\nSee also Boundary\n\n\n\n\n\n","category":"function"},{"location":"obs.html#Observables","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"obs.html#Obs.mpcac","page":"Observables","title":"Obs.mpcac","text":"mpcac(a0p,pp [,ca], bnd::Boundary = open)\n\nComputes the effective PCAC mass associated to the correlators a0p and a pp according to the boundary condition bnd. If ca is given, it first improve the a0p correlator according to  a0p-ca der_pp and then computes the pcac mass. It uses the symmetryc derivatives where necessary.\n\nOutput specifics\n\nIf a0p and/or pp are juobs.Corr, then according to bnd the code uses:\n\nbnd == open: the obs field where it strips the first and last component. This because in OBC  the first and last component lay on the boundary and are 0\nbnd == periodic: the obs field without modification\n\nSee also sym_der, Boundary, pa0_imp\n\n\n\n\n\n","category":"function"},{"location":"obs.html#Obs.meff","page":"Observables","title":"Obs.meff","text":" meff(v,bnd::Boundary=open)\n\nCompute the effective mass associated to the correlator v according to the boundary condition bnd.\n\nOutput Specifics\n\nThe length of the retuned vector is length(v)-1 if OBC, while is length(v) if PBC\n\n\n\n\n\n","category":"function"},{"location":"obs.html#Obs.ps_dec","page":"Observables","title":"Obs.ps_dec","text":" ps_dec(pa0,pp,mps,y0)\n\nIt computes the effective pseudoscalar decay constant associated to the correlator pa0 and pp. mps is the pseudoscalar mass and y0 is the source position.\n\nIf pa0 and pp are a juobs.Corr, y0 can be omitted and it will take the source position in pa0\n\n\n\n\n\n","category":"function"},{"location":"obs.html#Obs.dec","page":"Observables","title":"Obs.dec","text":" dec(c,m,y0)\n\nIt computes the effective decay constant associated to the correlator c. m is the mass associated to it and y0 the source position.\n\nIf c is a juobs.Corr, y0 can be omitted and it will take the source position in c\n\n\n\n\n\n","category":"function"},{"location":"obs.html#Obs.RI","page":"Observables","title":"Obs.RI","text":"RI(HtoL, H, L, EL, EH; xsink, xsrc)\n\nCompute the matrix element associated to the semileptonic decay H -> L using the ratio\n\n    R_I(t) = sqrt(2E_L) HtoL(t)sqrt(H(x_sink-t) L(t)) times  exp(frac12 (E_L t + E_H(x_sink-t)))\n\n\n\n\n\n","category":"function"},{"location":"obs.html#Obs.RII","page":"Observables","title":"Obs.RII","text":"RII(HtoL, H, L, EL, EH; xsink, xsrc)\n\nCompute the matrix element associated to the semileptonic decay H -> L using the ratio\n\n    R_II^2(t) = 2E_L fracHtoL(t)HtoL(x_sink-t)H(x_sink)L(x_sink)\n\n\n\n\n\n","category":"function"},{"location":"obs.html#Obs.RIII","page":"Observables","title":"Obs.RIII","text":"RIII(HtoL, H, L, EL, EH; xsink, xsrc)\n\nCompute the matrix element associated to the semileptonic decay H -> L using the ratio from 1903.05870 eq 5.1\n\n    R_III(t) = sqrt(2E_L) HtoL(t)sqrt(H(x_sink) L(x_sink)) times  exp(fracx_sink-2t2 (E_H - E_L))\n\n\n\n\n\n","category":"function"},{"location":"index.html#DOCUMENTATION","page":"Home","title":"DOCUMENTATION","text":"","category":"section"},{"location":"index.html#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"enum.md\", \"improvements.md\", \"obs.md\",\"utilities.md\"]\nDepth = 3","category":"page"},{"location":"enum.html#Enums-type","page":"Enum","title":"Enums type","text":"","category":"section"},{"location":"enum.html#Obs.Boundary","page":"Enum","title":"Obs.Boundary","text":"Boundary\n\nenum list that represent the boundary condition used in the data. As of now it can take the following value:\n\nopen = 0;\nperiodic = 1;\n\n\n\n\n\n","category":"type"},{"location":"enum.html#Obs.Check_flag","page":"Enum","title":"Obs.Check_flag","text":"Check_flag\n\nbitflag to select which juobs.Corr field not to check.\n\nElements:\n\n- no_flag   = 0x00\n- no_gamma  = 0x01\n- no_obs    = 0x02\n- no_kappa  = 0x04\n- no_mu     = 0x08\n- no_y0     = 0x10\n- no_theta1 = 0x20\n- no_theta2 = 0x40\n- no_thetas = no_theta1 | no_theta2\n\n\n\n\n\n","category":"type"}]
}
